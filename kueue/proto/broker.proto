syntax = "proto3";

option go_package = "kueue/kueue/proto";

import "kueue/proto/controller.proto";

service BrokerService {
  rpc ProduceMessage (ProduceRequest) returns (ProduceResponse); // producer -> leader partition broker
  rpc ConsumeMessage (ConsumeRequest) returns (ConsumeResponse); // consumer -> leader partition broker? allow replica to be read?
  rpc ReplicateMessage (ReplicateRequest) returns (ReplicateResponse); // leader partition broker -> replica partition broker
  rpc AppointAsLeader (AppointmentRequest) returns (AppointmentResponse); // controller -> leader partition broker
}

message AppointmentRequest {
  string topic_name = 1;
  int32 partition_id = 2;
  repeated BrokerInfoProto replica_brokers = 3;
}

// The broker should reject the appointment if it received ReplicateRequest within a timeout
// to prevent split-brain
message AppointmentResponse {
  bool leader_appointed = 1;
}

message AddTopicPartitionResponse {}

message ReplicateRequest {
  string topic_name = 1;
  int32 partition_id = 2;
  string leader_broker_id = 3;
  repeated ConsumerMessage messages = 4;
}

message ReplicateResponse {}

// Producer sends a ProduceRequest to the Broker
message ProduceRequest {
  string topic_name = 1;
  string producer_id = 2;
  int32 partition_id = 3; // determined by the key-hash
  repeated ProducerMessage messages = 4;
}

message ProducerMessage {
  string key = 1;
  string value = 2;
}
  
message ProduceResponse {
  string topic_name = 1;
  int32 base_offset = 2;
}

message ConsumeRequest {
  string topic_name = 1;
  int32 partition_id = 2;
  string consumer_id = 3;
}

message ConsumeResponse {
  string topic_name = 1;
  repeated ConsumerMessage records = 2;
}

message ConsumerMessage {
  int32 offset = 1;
  int64 timestamp = 2;
  string key = 3;
  string value = 4;
}
